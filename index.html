
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Catalog Manager Pro</title>
  <style>
    :root {
      --primary-color: #6366f1;
      --primary-hover: #4f46e5;
      --secondary-color: #64748b;
      --accent-color: #06b6d4;
      --success-color: #10b981;
      --warning-color: #f59e0b;
      --error-color: #ef4444;
      --background-dark: #0f172a;
      --background-light: #f1f5f9;
      --background-white: #ffffff;
      --border-color: #e2e8f0;
      --text-primary: #1e293b;
      --text-secondary: #64748b;
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
      --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
      --border-radius: 12px;
      --border-radius-lg: 16px;
      --gradient-primary: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #06b6d4 100%);
      --gradient-secondary: linear-gradient(135deg, #ec4899 0%, #f59e0b 100%);
      --gradient-success: linear-gradient(135deg, #10b981 0%, #059669 100%);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      color: var(--text-primary);
      line-height: 1.6;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .sidebar {
      width: 360px;
      background: var(--background-white);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-xl);
      position: relative;
      z-index: 10;
    }

    .sidebar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 200px;
      background: var(--gradient-primary);
      border-radius: 0 0 30px 0;
      opacity: 0.05;
      pointer-events: none;
    }

    .sidebar-header {
      padding: 32px 24px;
      background: var(--gradient-primary);
      color: white;
      border-radius: 0 0 30px 0;
      position: relative;
      overflow: hidden;
    }

    .sidebar-header::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      animation: shimmer 3s ease-in-out infinite;
    }

    @keyframes shimmer {
      0%, 100% { transform: scale(0.8) rotate(0deg); }
      50% { transform: scale(1.2) rotate(180deg); }
    }

    .sidebar-header h1 {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 8px;
      position: relative;
      z-index: 1;
    }

    .sidebar-header p {
      font-size: 14px;
      opacity: 0.9;
      position: relative;
      z-index: 1;
    }

    .sidebar-content {
      flex: 1;
      padding: 32px 24px;
      overflow-y: auto;
      position: relative;
    }

    .form-group {
      margin-bottom: 32px;
      position: relative;
    }

    .form-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 12px;
    }

    .form-label::before {
      content: '';
      width: 4px;
      height: 16px;
      background: var(--gradient-primary);
      border-radius: 2px;
    }

    .form-input, .form-select {
      width: 100%;
      padding: 16px;
      border: 2px solid var(--border-color);
      border-radius: var(--border-radius);
      font-size: 14px;
      background: var(--background-white);
      transition: all 0.3s ease;
      box-shadow: var(--shadow-sm);
    }

    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 4px rgb(99 102 241 / 0.1), var(--shadow-md);
      transform: translateY(-2px);
    }

    .file-input-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
      width: 100%;
    }

    .file-input-wrapper input[type=file] {
      position: absolute;
      left: -9999px;
    }

    .file-input-label {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      border: 3px dashed var(--border-color);
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, var(--background-light) 0%, var(--background-white) 100%);
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: 500;
      gap: 12px;
    }

    .file-input-label:hover {
      border-color: var(--primary-color);
      background: linear-gradient(135deg, rgb(99 102 241 / 0.05) 0%, rgb(99 102 241 / 0.02) 100%);
      color: var(--primary-color);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .file-input-label::before {
      content: 'üìÅ';
      font-size: 20px;
      filter: grayscale(1);
      transition: filter 0.3s ease;
    }

    .file-input-label:hover::before {
      filter: none;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-top: 32px;
    }

    .btn {
      padding: 16px 20px;
      border: none;
      border-radius: var(--border-radius);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.3s ease, height 0.3s ease;
    }

    .btn:hover::before {
      width: 300px;
      height: 300px;
    }

    .btn-primary {
      background: var(--gradient-primary);
      color: white;
      box-shadow: var(--shadow-md);
    }

    .btn-primary:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }

    .btn-secondary {
      background: var(--background-white);
      color: var(--text-secondary);
      border: 2px solid var(--border-color);
    }

    .btn-secondary:hover {
      background: var(--background-light);
      border-color: var(--secondary-color);
      transform: translateY(-2px);
    }

    .btn-success {
      background: var(--gradient-success);
      color: white;
      box-shadow: var(--shadow-md);
    }

    .btn-success:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }

    .stats-cards {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-top: 32px;
    }

    .stat-card {
      background: var(--background-white);
      padding: 24px 20px;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      text-align: center;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }

    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--gradient-primary);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-lg);
    }

    .stat-card:hover::before {
      transform: scaleX(1);
    }

    .stat-card-value {
      font-size: 32px;
      font-weight: 800;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 8px;
    }

    .stat-card-label {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--background-white);
      border-radius: 20px 0 0 0;
      margin-left: -10px;
      box-shadow: var(--shadow-xl);
    }

    .main-header {
      background: var(--background-white);
      border-bottom: 1px solid var(--border-color);
      padding: 32px 40px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
    }

    .main-header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 40px;
      right: 40px;
      height: 1px;
      background: linear-gradient(90deg, transparent 0%, var(--primary-color) 50%, transparent 100%);
    }

    .main-title {
      font-size: 32px;
      font-weight: 800;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 8px;
    }

    .breadcrumb {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 14px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .breadcrumb span:not(:last-child) {
      position: relative;
    }

    .breadcrumb span:not(:last-child)::after {
      content: '‚Üí';
      margin-left: 12px;
      color: var(--primary-color);
      font-weight: 600;
    }

    .row-indicator {
      display: flex;
      align-items: center;
      gap: 20px;
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: 500;
    }

    .navigation-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .nav-btn {
      padding: 12px 18px;
      border: 2px solid var(--border-color);
      background: var(--background-white);
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
      font-weight: 600;
      position: relative;
      overflow: hidden;
    }

    .nav-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.2), transparent);
      transition: left 0.5s ease;
    }

    .nav-btn:hover::before {
      left: 100%;
    }

    .nav-btn:hover {
      background: var(--background-light);
      border-color: var(--primary-color);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .nav-btn:disabled:hover {
      background: var(--background-white);
      border-color: var(--border-color);
    }

    .main-content {
      flex: 1;
      padding: 40px;
      overflow-y: auto;
      background: linear-gradient(135deg, var(--background-light) 0%, var(--background-white) 100%);
    }

    .field-group {
      background: var(--background-white);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius-lg);
      padding: 32px;
      margin-bottom: 32px;
      box-shadow: var(--shadow-md);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .field-group::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: var(--gradient-primary);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .field-group:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-lg);
    }

    .field-group:hover::before {
      transform: scaleX(1);
    }

    .field-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 20px;
    }

    .field-label-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .field-counter {
      background: var(--background-light);
      color: var(--text-secondary);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid var(--border-color);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .field-type-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
    }

    .field-type-product-type { background: linear-gradient(135deg, #6366f1, #8b5cf6); }
    .field-type-product-name { background: linear-gradient(135deg, #f59e0b, #d97706); }
    .field-type-short-desc { background: linear-gradient(135deg, #10b981, #059669); }
    .field-type-long-desc { background: linear-gradient(135deg, #ef4444, #dc2626); }
    .field-type-main-image { background: linear-gradient(135deg, #8b5cf6, #a855f7); }
    .field-type-secondary-image { background: linear-gradient(135deg, #06b6d4, #0891b2); }

    .field-content {
      font-size: 15px;
      line-height: 1.7;
    }

    .editable {
      background: linear-gradient(135deg, var(--background-light) 0%, var(--background-white) 100%);
      border: 2px solid var(--border-color);
      border-radius: var(--border-radius);
      padding: 20px;
      min-height: 140px;
      white-space: pre-wrap;
      overflow-y: auto;
      transition: all 0.3s ease;
      font-size: 15px;
      line-height: 1.6;
    }

    .editable:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 4px rgb(99 102 241 / 0.1), var(--shadow-md);
      transform: translateY(-2px);
    }

    .editable-bullets {
      background: linear-gradient(135deg, var(--background-light) 0%, var(--background-white) 100%);
      border: 2px solid var(--border-color);
      border-radius: var(--border-radius);
      padding: 20px;
      min-height: 180px;
      overflow-y: auto;
      transition: all 0.3s ease;
      line-height: 1.8;
      font-size: 15px;
    }

    .editable-bullets:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 4px rgb(99 102 241 / 0.1), var(--shadow-md);
      transform: translateY(-2px);
    }

    .editable-bullets ul {
      margin: 0;
      padding-left: 24px;
    }

    .editable-bullets li {
      margin-bottom: 12px;
      padding-left: 8px;
      position: relative;
    }

    .editable-bullets li::marker {
      color: var(--primary-color);
      font-weight: bold;
    }

    .bullet-helper {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 12px;
      padding: 12px 16px;
      background: linear-gradient(135deg, rgb(99 102 241 / 0.05) 0%, rgb(99 102 241 / 0.02) 100%);
      border: 1px solid rgb(99 102 241 / 0.2);
      border-radius: var(--border-radius);
      font-style: italic;
      border-left: 4px solid var(--primary-color);
    }

    .image-gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 20px;
      margin-top: 16px;
    }

    .image-item {
      position: relative;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--shadow-md);
      transition: all 0.3s ease;
      background: var(--background-white);
    }

    .image-item:hover {
      transform: scale(1.05) translateY(-4px);
      box-shadow: var(--shadow-lg);
    }

    .image-item img {
      width: 100px;
      height: 100px;
      object-fit: cover;
      cursor: pointer;
      display: block;
      transition: all 0.3s ease;
    }

    .image-item:hover img {
      filter: brightness(1.1);
    }

    .image-count {
      background: var(--gradient-primary);
      color: white;
      padding: 8px 16px;
      border-radius: 25px;
      font-size: 12px;
      font-weight: 600;
      display: inline-block;
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: var(--shadow-sm);
    }

    .popup {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(20px);
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .popup img {
      max-width: 90vw;
      max-height: 90vh;
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-xl);
      animation: zoomIn 0.3s ease;
    }

    @keyframes zoomIn {
      from { transform: scale(0.9); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .highlight {
      background: linear-gradient(120deg, #fbbf24 0%, #f59e0b 100%);
      padding: 4px 8px;
      border-radius: 6px;
      font-weight: 600;
      color: white;
      box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .empty-state {
      text-align: center;
      padding: 80px;
      color: var(--text-secondary);
      background: var(--background-white);
      border-radius: var(--border-radius-lg);
      border: 2px dashed var(--border-color);
    }

    .empty-state-icon {
      font-size: 64px;
      margin-bottom: 24px;
      opacity: 0.5;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }

    .empty-state h3 {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 12px;
      color: var(--text-primary);
    }

    .empty-state p {
      font-size: 16px;
      color: var(--text-secondary);
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--background-light);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--gradient-primary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--primary-hover);
    }

    /* Loading animation */
    .loading {
      position: relative;
      overflow: hidden;
    }

    .loading::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: loading 1.5s infinite;
    }

    @keyframes loading {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .sidebar {
        width: 320px;
      }
      
      .main-content {
        padding: 20px;
      }
      
      .stats-cards {
        grid-template-columns: 1fr;
      }
      
      .field-group {
        padding: 20px;
      }
      
      .main-header {
        padding: 20px;
        flex-direction: column;
        gap: 20px;
        align-items: flex-start;
      }
      
      .navigation-controls {
        flex-direction: column;
        gap: 8px;
      }
    }

    /* Success notification */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--gradient-success);
      color: white;
      padding: 20px 28px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-lg);
      z-index: 1001;
      font-weight: 600;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="sidebar-header">
      <h1>Catalog Manager Pro</h1>
      <p>Professional product catalog management</p>
    </div>
    
    <div class="sidebar-content">
      <div class="form-group">
        <label class="form-label">Upload Excel File</label>
        <div class="file-input-wrapper">
          <input type="file" id="fileInput" accept=".xlsx" onchange="loadExcelFile()" />
          <label for="fileInput" class="file-input-label">
            üìÅ Choose Excel File
          </label>
        </div>
      </div>

      <div class="form-group">
        <label class="form-label" for="filter">Filter by Product Type</label>
        <select id="filter" class="form-select" onchange="applyFilter()">
          <option value="">All Product Types</option>
        </select>
      </div>

      <div class="form-group">
        <label class="form-label" for="searchInput">Search Keywords</label>
        <input 
  type="text" 
  id="searchInput" 
  class="form-input" 
  placeholder="Enter keywords (comma-separated)..." 
  oninput="saveCurrentEdits(); highlightKeywords();" 
/>
      </div>

      <div class="controls">
        <button class="btn btn-primary" onclick="saveChanges()">
          üíæ Save Changes
        </button>
        <button class="btn btn-success" onclick="downloadExcel()">
          üì• Download Excel
        </button>
      </div>

      <div class="stats-cards">
        <div class="stat-card">
          <div class="stat-card-value" id="totalProductTypes">0</div>
          <div class="stat-card-label">Product Types</div>
        </div>
        <div class="stat-card">
          <div class="stat-card-value" id="totalRows">0</div>
          <div class="stat-card-label">Total Items</div>
        </div>
        <div class="stat-card">
          <div class="stat-card-value" id="filteredRows">0</div>
          <div class="stat-card-label">Filtered Items</div>
        </div>
        <div class="stat-card">
          <div class="stat-card-value" id="currentRowDisplay">-</div>
          <div class="stat-card-label">Current Row</div>
        </div>
      </div>
    </div>
  </div>

  <div class="main">
    <div class="main-header">
      <div>
        <h2 class="main-title">Product Details</h2>
        <div class="breadcrumb">
          <span>Catalog</span>
          <span>‚Üí</span>
          <span id="currentProductType">All Products</span>
        </div>
      </div>
      <div class="row-indicator">
        <div class="navigation-controls">
          <button class="nav-btn" onclick="prevRow()" id="prevBtn">‚Üê Previous</button>
          <span id="rowIndexDisplay">No data</span>
          <button class="nav-btn" onclick="nextRow()" id="nextBtn">Next ‚Üí</button>
        </div>
      </div>
    </div>

    <div class="main-content">
      <div id="detailsView">
        <div class="empty-state">
          <div class="empty-state-icon">üìã</div>
          <h3>No Data Loaded</h3>
          <p>Please upload an Excel file to get started</p>
        </div>
      </div>
    </div>
  </div>

  <div id="imagePopup" class="popup" style="display: none;" onclick="closePopup()">
    <img id="popupImage" src="" alt="Expanded View" />
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script>
    let workbook,
        originalData = [],
        filteredData = [],
        currentIndex = 0,
        uploadedFileName = "Updated_Products.xlsx";

    const fieldMap = {
      "Product Type": { label: "Product Type", className: "field-type-product-type" },
      "Product Name": { label: "Product Name", className: "field-type-product-name" },
      "Product Short Description": { label: "Short Description", className: "field-type-short-desc" },
      "Product Long Description": { label: "Long Description", className: "field-type-long-desc" },
      "Main Image URL": { label: "Main Image", className: "field-type-main-image" },
      "Product Secondary Image URL": { label: "Secondary Images", className: "field-type-secondary-image" },
    };

    function loadExcelFile() {
      const file = document.getElementById("fileInput").files[0];
      if (!file) return;

      uploadedFileName = file.name || "Updated_Products.xlsx";
      
      const reader = new FileReader();
      reader.onload = function (e) {
        const data = new Uint8Array(e.target.result);
        workbook = XLSX.read(data, { type: "array" });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        originalData = XLSX.utils.sheet_to_json(sheet, { defval: "" });
        filteredData = [...originalData];
        populateFilterOptions(originalData);
        showRowDetails(0);
        updateStats();
      };
      reader.readAsArrayBuffer(file);
    }

    function populateFilterOptions(data) {
      const filter = document.getElementById("filter");
      filter.innerHTML = '<option value="">All Product Types</option>';
      const productTypes = [...new Set(data.map((item) => item["Product Type"]))].sort();
      productTypes.forEach((type) => {
        const option = document.createElement("option");
        option.value = type;
        option.textContent = type;
        filter.appendChild(option);
      });
    }

    function showRowDetails(index) {
      currentIndex = index;
      const detailsView = document.getElementById("detailsView");
      const rowData = filteredData[index];
      
      if (!rowData) {
        detailsView.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üìÑ</div>
            <h3>No Data Available</h3>
            <p>No items match your current filter criteria</p>
          </div>
        `;
        return;
      }

      const rowNumber = originalData.indexOf(rowData) + 2;
      document.getElementById("rowIndexDisplay").textContent = `${currentIndex + 1} of ${filteredData.length}`;
      
      detailsView.innerHTML = "";

      Object.keys(fieldMap).forEach((key) => {
        const fieldGroup = document.createElement("div");
        fieldGroup.className = "field-group";

        const label = document.createElement("div");
        label.className = "field-label";
        
        const labelLeft = document.createElement("div");
        labelLeft.className = "field-label-left";
        labelLeft.innerHTML = `
          <span class="field-type-indicator ${fieldMap[key].className}"></span>
          ${fieldMap[key].label}
        `;
        
        label.appendChild(labelLeft);
        
        // Add counter for specific fields
        if (key === "Product Short Description" || key === "Product Long Description") {
          const counter = document.createElement("div");
          counter.className = "field-counter";
          counter.id = `counter-${key.replace(/\s+/g, '-').toLowerCase()}`;
          label.appendChild(counter);
        }
        
        fieldGroup.appendChild(label);

        const content = document.createElement("div");
        content.className = "field-content";

        if (key === "Product Short Description" || key === "Product Long Description") {
          const editableDiv = document.createElement("div");
          
     if (key === "Product Long Description") {
  editableDiv.className = "editable-bullets";
  editableDiv.contentEditable = true;
  
  // Convert plain text to proper HTML list format
  const textContent = rowData[key] || "";
  const formattedContent = formatTextToProperHTML(textContent);
  editableDiv.innerHTML = formattedContent;
  
  // Add helper text
  const helper = document.createElement("div");
  helper.className = "bullet-helper";
  helper.textContent = "üí° Press Enter to create new bullet points. Use backspace to remove bullets.";
  content.appendChild(helper);
  
  // Handle Enter key for proper list items
  editableDiv.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const currentNode = range.startContainer;
      
      // Check if we're inside a list item
      const currentLi = currentNode.nodeType === Node.TEXT_NODE ? 
        currentNode.parentElement.closest('li') : 
        currentNode.closest('li');
      
      if (currentLi) {
        const currentUl = currentLi.closest('ul');
        
        // Split the content at cursor position
        const textAfterCursor = extractTextAfterCursor(range);
        
        // Create new list item with the text after cursor
        const newLi = document.createElement('li');
        if (textAfterCursor.trim()) {
          newLi.innerHTML = textAfterCursor;
        } else {
          newLi.innerHTML = '&nbsp;'; // Add non-breaking space for cursor placement
        }
        
        // Remove text after cursor from current li
        removeTextAfterCursor(range);
        
        // Insert after current li
        currentLi.insertAdjacentElement('afterend', newLi);
        
        // Move cursor to beginning of new li
        const newRange = document.createRange();
        newRange.selectNodeContents(newLi);
        newRange.collapse(true);
        selection.removeAllRanges();
        selection.addRange(newRange);
      } else {
        // If not in a list, create a new ul with li
        const ul = document.createElement('ul');
        const li = document.createElement('li');
        
        // Get text at cursor position
        const textAtCursor = extractTextAfterCursor(range);
        if (textAtCursor.trim()) {
          li.innerHTML = textAtCursor;
          removeTextAfterCursor(range);
        } else {
          li.innerHTML = '&nbsp;';
        }
        
        ul.appendChild(li);
        
        // Insert at cursor position
        range.insertNode(ul);
        range.collapse(false);
        
        // Move cursor to new li
        const newRange = document.createRange();
        newRange.selectNodeContents(li);
        newRange.collapse(true);
        selection.removeAllRanges();
        selection.addRange(newRange);
      }
    }
    
    
    // Handle backspace to remove empty list items
   if (e.key === 'Backspace') {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const currentNode = range.startContainer;
      
      const currentLi = currentNode.nodeType === Node.TEXT_NODE ? 
        currentNode.parentElement.closest('li') : 
        currentNode.closest('li');
      
      if (currentLi && (currentLi.textContent.trim() === '' || currentLi.innerHTML.trim() === '&nbsp;')) {
        e.preventDefault();
        
        const prevLi = currentLi.previousElementSibling;
        const nextLi = currentLi.nextElementSibling;
        const parentUl = currentLi.parentElement;
        
        if (prevLi) {
          // Move cursor to end of previous li
          const newRange = document.createRange();
          newRange.selectNodeContents(prevLi);
          newRange.collapse(false);
          selection.removeAllRanges();
          selection.addRange(newRange);
        } else if (nextLi) {
          // Move cursor to beginning of next li
          const newRange = document.createRange();
          newRange.selectNodeContents(nextLi);
          newRange.collapse(true);
          selection.removeAllRanges();
          selection.addRange(newRange);
        }
        
        // Remove the empty li
        currentLi.remove();
        
        // If ul is empty, remove it
        if (parentUl && parentUl.children.length === 0) {
          parentUl.remove();
        }
      }
    }
  });
}
else {
            editableDiv.className = "editable";
            editableDiv.contentEditable = true;
            editableDiv.innerHTML = rowData[key] || "";
          }
          
          editableDiv.dataset.index = index;
          editableDiv.dataset.key = key;
          editableDiv.dataset.original = rowData[key] || "";
          
         editableDiv.oninput = function () {
  const content = editableDiv.innerHTML;
  filteredData[index][key] = content;
  const originalIndex = originalData.indexOf(rowData);
  if (originalIndex !== -1) {
    originalData[originalIndex][key] = content;
  }
  // Update the original data storage for highlighting
  editableDiv.dataset.original = content;
  updateFieldCounter(key, content);
};
          
          content.appendChild(editableDiv);
          
          // Initialize counter immediately
          setTimeout(() => updateFieldCounter(key, editableDiv.innerHTML), 0);
        } else if (key === "Main Image URL") {
          if (rowData[key]) {
            const imageGallery = document.createElement("div");
            imageGallery.className = "image-gallery";
            const imageItem = document.createElement("div");
            imageItem.className = "image-item";
            const img = document.createElement("img");
            img.src = rowData[key];
            img.alt = "Main Image";
            img.onclick = () => expandImage(rowData[key]);
            imageItem.appendChild(img);
            imageGallery.appendChild(imageItem);
            content.appendChild(imageGallery);
          } else {
            content.innerHTML = '<p style="color: var(--text-secondary); font-style: italic;">No main image available</p>';
          }
        } else if (key === "Product Secondary Image URL") {
          const urls = rowData[key] ? rowData[key].split(",").map(url => url.trim()).filter(Boolean) : [];
          if (urls.length > 0) {
            const countSpan = document.createElement("div");
            countSpan.className = "image-count";
            countSpan.textContent = `${urls.length} secondary images`;
            content.appendChild(countSpan);
            
            const imageGallery = document.createElement("div");
            imageGallery.className = "image-gallery";
            
            urls.forEach((url) => {
              const imageItem = document.createElement("div");
              imageItem.className = "image-item";
              const img = document.createElement("img");
              img.src = url;
              img.alt = "Secondary Image";
              img.onclick = () => expandImage(url);
              imageItem.appendChild(img);
              imageGallery.appendChild(imageItem);
            });
            content.appendChild(imageGallery);
          } else {
            content.innerHTML = '<p style="color: var(--text-secondary); font-style: italic;">No secondary images available</p>';
          }
        } else {
          const p = document.createElement("p");
          p.textContent = rowData[key] || "Not specified";
          if (!rowData[key]) {
            p.style.color = "var(--text-secondary)";
            p.style.fontStyle = "italic";
          }
          content.appendChild(p);
        }

        fieldGroup.appendChild(content);
        detailsView.appendChild(fieldGroup);
      });

      highlightKeywords();
      updateNavigationButtons();
      updateCurrentProductType();
    }

    function updateNavigationButtons() {
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      
      prevBtn.disabled = currentIndex === 0;
      nextBtn.disabled = currentIndex === filteredData.length - 1;
    }

    function updateCurrentProductType() {
      const currentFilter = document.getElementById("filter").value;
      const currentProductTypeElement = document.getElementById("currentProductType");
      
      if (currentFilter) {
        currentProductTypeElement.textContent = currentFilter;
      } else {
        currentProductTypeElement.textContent = "All Products";
      }
    }

    function formatTextToProperHTML(text) {
  if (!text || text.trim() === '') return '';
  
  // If the text already contains proper HTML structure, return as is
  if (text.includes('<ul>') && text.includes('<li>')) {
    return text;
  }
  
  // If it contains the old br‚Ä¢ format, convert it
  if (text.includes('<br>‚Ä¢')) {
    // Convert br‚Ä¢ format to proper HTML
    let converted = text.replace(/<br>\s*‚Ä¢\s*/g, '</li><li>');
    
    // Handle starting bullet
    if (converted.startsWith('‚Ä¢')) {
      converted = converted.substring(1).trim();
    }
    
    // Wrap in ul/li structure
    if (converted.includes('</li><li>')) {
      converted = '<ul><li>' + converted + '</li></ul>';
    } else {
      converted = '<ul><li>' + converted + '</li></ul>';
    }
    
    return converted;
  }
  
  // Handle plain text conversion
  const lines = text.split('\n').filter(line => line.trim() !== '');
  
  if (lines.length === 0) return '';
  
  // Group lines into different sections (paragraphs, lists, etc.)
  const sections = [];
  let currentSection = { type: 'paragraph', content: [] };
  
  lines.forEach(line => {
    const trimmed = line.trim();
    
    // Check if it's a bullet point
    if (trimmed.match(/^[‚Ä¢\-*]\s+/) || trimmed.match(/^\d+\.\s+/)) {
      // If current section is not a list, start a new list section
      if (currentSection.type !== 'list') {
        if (currentSection.content.length > 0) {
          sections.push(currentSection);
        }
        currentSection = { type: 'list', content: [] };
      }
      // Remove bullet characters and add to list
      const cleanedLine = trimmed.replace(/^[‚Ä¢\-*]\s+/, '').replace(/^\d+\.\s+/, '');
      currentSection.content.push(cleanedLine);
    } else {
      // Regular paragraph content
      if (currentSection.type !== 'paragraph') {
        if (currentSection.content.length > 0) {
          sections.push(currentSection);
        }
        currentSection = { type: 'paragraph', content: [] };
      }
      currentSection.content.push(trimmed);
    }
  });
  
  // Add the last section
  if (currentSection.content.length > 0) {
    sections.push(currentSection);
  }
  
  // Convert sections to HTML
  return sections.map(section => {
    if (section.type === 'list') {
      const listItems = section.content.map(item => `<li>${item}</li>`).join('');
      return `<ul>${listItems}</ul>`;
    } else {
      return `<p>${section.content.join('<br>')}</p>`;
    }
  }).join('');
}

// Helper functions for text splitting
function extractTextAfterCursor(range) {
  const startContainer = range.startContainer;
  const startOffset = range.startOffset;
  
  if (startContainer.nodeType === Node.TEXT_NODE) {
    // Get text after cursor position
    const textNode = startContainer;
    const fullText = textNode.textContent;
    const textAfterCursor = fullText.substring(startOffset);
    
    // Also check for any following sibling nodes
    let nextSibling = textNode.nextSibling;
    let additionalText = '';
    
    while (nextSibling) {
      if (nextSibling.nodeType === Node.TEXT_NODE) {
        additionalText += nextSibling.textContent;
      } else if (nextSibling.nodeType === Node.ELEMENT_NODE) {
        additionalText += nextSibling.outerHTML;
      }
      nextSibling = nextSibling.nextSibling;
    }
    
    return textAfterCursor + additionalText;
  } else {
    // If cursor is in an element node, get all content after cursor
    const element = startContainer;
    const childNodes = Array.from(element.childNodes);
    const nodesAfterCursor = childNodes.slice(startOffset);
    
    return nodesAfterCursor.map(node => {
      if (node.nodeType === Node.TEXT_NODE) {
        return node.textContent;
      } else {
        return node.outerHTML;
      }
    }).join('');
  }
}
function removeTextAfterCursor(range) {
  const startContainer = range.startContainer;
  const startOffset = range.startOffset;
  
  if (startContainer.nodeType === Node.TEXT_NODE) {
    const textNode = startContainer;
    const fullText = textNode.textContent;
    
    // Keep only text before cursor
    textNode.textContent = fullText.substring(0, startOffset);
    
    // Remove all following sibling nodes
    let nextSibling = textNode.nextSibling;
    while (nextSibling) {
      const nodeToRemove = nextSibling;
      nextSibling = nextSibling.nextSibling;
      nodeToRemove.remove();
    }
  } else {
    // If cursor is in an element node, remove all nodes after cursor
    const element = startContainer;
    const childNodes = Array.from(element.childNodes);
    const nodesToRemove = childNodes.slice(startOffset);
    
    nodesToRemove.forEach(node => node.remove());
  }
}
    function updateStats() {
      const totalPTs = new Set(originalData.map(row => row["Product Type"])).size;
      const totalRows = originalData.length;
      const filteredRows = filteredData.length;
      const currentRowIndex = filteredData[currentIndex] ? originalData.indexOf(filteredData[currentIndex]) + 2 : "-";

      document.getElementById("totalProductTypes").textContent = totalPTs;
      document.getElementById("totalRows").textContent = totalRows;
      document.getElementById("filteredRows").textContent = filteredRows;
      document.getElementById("currentRowDisplay").textContent = currentRowIndex;
    }

    function applyFilter() {
      const value = document.getElementById("filter").value;
      filteredData = value ? originalData.filter((row) => row["Product Type"] === value) : [...originalData];
      currentIndex = 0;
      showRowDetails(0);
      updateStats();
    }

    function nextRow() {
      if (currentIndex < filteredData.length - 1) {
        showRowDetails(currentIndex + 1);
      }
    }

    function prevRow() {
      if (currentIndex > 0) {
        showRowDetails(currentIndex - 1);
      }
    }

    function saveChanges() {
      // Create a simple notification
      const notification = document.createElement("div");
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--success-color);
        color: white;
        padding: 16px 24px;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-lg);
        z-index: 1001;
        font-weight: 500;
      `;
      notification.textContent = "‚úÖ Changes saved successfully!";
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    function downloadExcel() {
      if (!workbook) return;
      
      const sheetName = workbook.SheetNames[0];
      const sheet = workbook.Sheets[sheetName];
      const headers = Object.keys(originalData[0]);

      for (let r = 0; r < originalData.length; r++) {
        const rowNum = r + 2;
        headers.forEach((header, c) => {
          const cellAddr = XLSX.utils.encode_col(c) + rowNum;
          sheet[cellAddr] = { t: "s", v: originalData[r][header] };
        });
      }

      XLSX.writeFile(workbook, uploadedFileName);
    }

    function expandImage(src) {
      document.getElementById("popupImage").src = src;
      document.getElementById("imagePopup").style.display = "flex";
    }

    function closePopup() {
      document.getElementById("imagePopup").style.display = "none";
      document.getElementById("popupImage").src = "";
    }

    function normalizeWord(word) {
      if (word.length > 2) {
        return word.replace(/('s|s)$/i, "").toLowerCase();
      }
      return word.toLowerCase();
    }

    function highlightKeywords() {
  const input = document.getElementById("searchInput").value.trim();
  if (!input) {
    // Instead of reverting to original, just remove highlights
    document.querySelectorAll(".editable").forEach((div) => {
      const content = div.innerHTML;
      // Remove existing highlights
      div.innerHTML = content.replace(/<span class="highlight">(.*?)<\/span>/g, '$1');
    });
    return;
  }

  const keywords = input
    .split(",")
    .map((k) => k.trim())
    .filter((k) => k.length > 0);

  document.querySelectorAll(".editable").forEach((div) => {
    // Get current content (not original)
    let content = div.innerHTML;
    
    // Remove existing highlights first
    content = content.replace(/<span class="highlight">(.*?)<\/span>/g, '$1');

    // Sort keywords by length (longest first) to prioritize longer phrases
    const sortedKeywords = keywords.sort((a, b) => b.length - a.length);

    // Apply highlighting for each keyword/phrase
    sortedKeywords.forEach((keyword) => {
      // Create a case-insensitive regex that matches whole words or phrases
      // Use word boundaries for single words, but allow phrase matching
      const isMultiWord = keyword.includes(' ');
      
      if (isMultiWord) {
        // For multi-word phrases, create a regex that matches the entire phrase
        const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const phraseRegex = new RegExp(`\\b${escapedKeyword}\\b`, 'gi');
        content = content.replace(phraseRegex, `<span class="highlight">$&</span>`);
      } else {
        // For single words, use the existing word boundary approach
        const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const wordRegex = new RegExp(`\\b${escapedKeyword}\\b`, 'gi');
        content = content.replace(wordRegex, `<span class="highlight">$&</span>`);
      }
    });

    div.innerHTML = content;
  });
}

function saveCurrentEdits() {
  // Save any current edits before applying highlights
  document.querySelectorAll(".editable").forEach((div) => {
    const index = parseInt(div.dataset.index);
    const key = div.dataset.key;
    const content = div.innerHTML;
    
    if (filteredData[index] && key) {
      filteredData[index][key] = content;
      const originalIndex = originalData.indexOf(filteredData[index]);
      if (originalIndex !== -1) {
        originalData[originalIndex][key] = content;
      }
      // Update the stored original data
      div.dataset.original = content;
    }
  });
}
    // Also add this new function to replace formatTextToBullets:
function formatTextToProperHTML(text) {
  if (!text || text.trim() === '') return '';
  
  // If the text already contains proper HTML structure, return as is
  if (text.includes('<ul>') && text.includes('<li>')) {
    return text;
  }
  
  // If it contains the old br‚Ä¢ format, convert it
  if (text.includes('<br>‚Ä¢')) {
    // Convert br‚Ä¢ format to proper HTML
    let converted = text.replace(/<br>\s*‚Ä¢\s*/g, '</li><li>');
    
    // Handle starting bullet
    if (converted.startsWith('‚Ä¢')) {
      converted = converted.substring(1).trim();
    }
    
    // Wrap in ul/li structure
    if (converted.includes('</li><li>')) {
      converted = '<ul><li>' + converted + '</li></ul>';
    } else {
      converted = '<ul><li>' + converted + '</li></ul>';
    }
    
    return converted;
  }
  
  // Handle plain text conversion
  const lines = text.split('\n').filter(line => line.trim() !== '');
  
  if (lines.length === 0) return '';
  
  // Group lines into different sections (paragraphs, lists, etc.)
  const sections = [];
  let currentSection = { type: 'paragraph', content: [] };
  
  lines.forEach(line => {
    const trimmed = line.trim();
    
    // Check if it's a bullet point
    if (trimmed.match(/^[‚Ä¢\-*]\s+/) || trimmed.match(/^\d+\.\s+/)) {
      // If current section is not a list, start a new list section
      if (currentSection.type !== 'list') {
        if (currentSection.content.length > 0) {
          sections.push(currentSection);
        }
        currentSection = { type: 'list', content: [] };
      }
      // Remove bullet characters and add to list
      const cleanedLine = trimmed.replace(/^[‚Ä¢\-*]\s+/, '').replace(/^\d+\.\s+/, '');
      currentSection.content.push(cleanedLine);
    } else {
      // Regular paragraph content
      if (currentSection.type !== 'paragraph') {
        if (currentSection.content.length > 0) {
          sections.push(currentSection);
        }
        currentSection = { type: 'paragraph', content: [] };
      }
      currentSection.content.push(trimmed);
    }
  });
  
  // Add the last section
  if (currentSection.content.length > 0) {
    sections.push(currentSection);
  }
  
  // Convert sections to HTML
  return sections.map(section => {
    if (section.type === 'list') {
      const listItems = section.content.map(item => `<li>${item}</li>`).join('');
      return `<ul>${listItems}</ul>`;
    } else {
      return `<p>${section.content.join('<br>')}</p>`;
    }
  }).join('');
}

// Update the bullet counting function:
function updateFieldCounter(fieldKey, content) {
  const counterId = `counter-${fieldKey.replace(/\s+/g, '-').toLowerCase()}`;
  const counterElement = document.getElementById(counterId);
  
  if (!counterElement) return;
  
  // Remove HTML tags and get plain text
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = content;
  const plainText = tempDiv.textContent || tempDiv.innerText || '';
  
  if (fieldKey === "Product Short Description") {
    // Count words
    const words = plainText.trim().split(/\s+/).filter(word => word.length > 0);
    const wordCount = words.length;
    counterElement.textContent = `${wordCount} words`;
    
    // Add color coding based on word count
    if (wordCount === 0) {
      counterElement.style.background = 'var(--background-light)';
      counterElement.style.color = 'var(--text-secondary)';
    } else if (wordCount <= 20) {
      counterElement.style.background = '#dcfce7';
      counterElement.style.color = '#166534';
    } else if (wordCount <= 40) {
      counterElement.style.background = '#fef3c7';
      counterElement.style.color = '#92400e';
    } else {
      counterElement.style.background = '#fee2e2';
      counterElement.style.color = '#991b1b';
    }
  } else if (fieldKey === "Product Long Description") {
    // Count proper list items
    const listItems = content.match(/<li>/g) || [];
    const bulletCount = listItems.length;
    
    counterElement.textContent = `${bulletCount} bullet points`;
    
    // Add color coding based on bullet count
    if (bulletCount === 0) {
      counterElement.style.background = 'var(--background-light)';
      counterElement.style.color = 'var(--text-secondary)';
    } else if (bulletCount <= 3) {
      counterElement.style.background = '#dcfce7';
      counterElement.style.color = '#166534';
    } else if (bulletCount <= 6) {
      counterElement.style.background = '#fef3c7';
      counterElement.style.color = '#92400e';
    } else {
      counterElement.style.background = '#fee2e2';
      counterElement.style.color = '#991b1b';
    }
  }
}

    // Initialize the app
    document.addEventListener("DOMContentLoaded", function() {
      updateStats();
      updateNavigationButtons();
    });
  </script>
</body>
</html>
